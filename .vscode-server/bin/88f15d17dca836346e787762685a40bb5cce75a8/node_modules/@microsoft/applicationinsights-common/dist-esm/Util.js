// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { StorageType } from "./Enums";
import { CoreUtils, _InternalMessageId, LoggingSeverity } from "@microsoft/applicationinsights-core-js";
import { RequestHeaders } from "./RequestResponseHeaders";
import { DataSanitizer } from "./Telemetry/Common/DataSanitizer";
var Util = /** @class */ (function () {
    function Util() {
    }
    /*
     * Force the SDK not to use local and session storage
    */
    Util.disableStorage = function () {
        Util._canUseLocalStorage = false;
        Util._canUseSessionStorage = false;
    };
    /**
     * Gets the localStorage object if available
     * @return {Storage} - Returns the storage object if available else returns null
     */
    Util._getLocalStorageObject = function () {
        if (Util.canUseLocalStorage()) {
            return Util._getVerifiedStorageObject(StorageType.LocalStorage);
        }
        return null;
    };
    /**
     * Tests storage object (localStorage or sessionStorage) to verify that it is usable
     * More details here: https://mathiasbynens.be/notes/localstorage-pattern
     * @param storageType Type of storage
     * @return {Storage} Returns storage object verified that it is usable
     */
    Util._getVerifiedStorageObject = function (storageType) {
        var storage = null;
        var fail;
        var uid;
        try {
            if (typeof window === 'undefined') {
                return null;
            }
            uid = new Date;
            storage = storageType === StorageType.LocalStorage ? window.localStorage : window.sessionStorage;
            storage.setItem(uid, uid);
            fail = storage.getItem(uid) != uid;
            storage.removeItem(uid);
            if (fail) {
                storage = null;
            }
        }
        catch (exception) {
            storage = null;
        }
        return storage;
    };
    /**
     *  Checks if endpoint URL is application insights internal injestion service URL.
     *
     *  @param endpointUrl Endpoint URL to check.
     *  @returns {boolean} True if if endpoint URL is application insights internal injestion service URL.
     */
    Util.isInternalApplicationInsightsEndpoint = function (endpointUrl) {
        return Util._internalEndpoints.indexOf(endpointUrl.toLowerCase()) !== -1;
    };
    /**
     *  Check if the browser supports local storage.
     *
     *  @returns {boolean} True if local storage is supported.
     */
    Util.canUseLocalStorage = function () {
        if (Util._canUseLocalStorage === undefined) {
            Util._canUseLocalStorage = !!Util._getVerifiedStorageObject(StorageType.LocalStorage);
        }
        return Util._canUseLocalStorage;
    };
    /**
     *  Get an object from the browser's local storage
     *
     *  @param {string} name - the name of the object to get from storage
     *  @returns {string} The contents of the storage object with the given name. Null if storage is not supported.
     */
    Util.getStorage = function (logger, name) {
        var storage = Util._getLocalStorageObject();
        if (storage !== null) {
            try {
                return storage.getItem(name);
            }
            catch (e) {
                Util._canUseLocalStorage = false;
                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotReadLocalStorage, "Browser failed read of local storage. " + Util.getExceptionName(e), { exception: Util.dump(e) });
            }
        }
        return null;
    };
    /**
     *  Set the contents of an object in the browser's local storage
     *
     *  @param {string} name - the name of the object to set in storage
     *  @param {string} data - the contents of the object to set in storage
     *  @returns {boolean} True if the storage object could be written.
     */
    Util.setStorage = function (logger, name, data) {
        var storage = Util._getLocalStorageObject();
        if (storage !== null) {
            try {
                storage.setItem(name, data);
                return true;
            }
            catch (e) {
                Util._canUseLocalStorage = false;
                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotWriteLocalStorage, "Browser failed write to local storage. " + Util.getExceptionName(e), { exception: Util.dump(e) });
            }
        }
        return false;
    };
    /**
     *  Remove an object from the browser's local storage
     *
     *  @param {string} name - the name of the object to remove from storage
     *  @returns {boolean} True if the storage object could be removed.
     */
    Util.removeStorage = function (logger, name) {
        var storage = Util._getLocalStorageObject();
        if (storage !== null) {
            try {
                storage.removeItem(name);
                return true;
            }
            catch (e) {
                Util._canUseLocalStorage = false;
                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserFailedRemovalFromLocalStorage, "Browser failed removal of local storage item. " + Util.getExceptionName(e), { exception: Util.dump(e) });
            }
        }
        return false;
    };
    /**
     * Gets the sessionStorage object if available
     * @return {Storage} - Returns the storage object if available else returns null
     */
    Util._getSessionStorageObject = function () {
        if (Util.canUseSessionStorage()) {
            return Util._getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return null;
    };
    /**
     *  Check if the browser supports session storage.
     *
     *  @returns {boolean} True if session storage is supported.
     */
    Util.canUseSessionStorage = function () {
        if (Util._canUseSessionStorage === undefined) {
            Util._canUseSessionStorage = !!Util._getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return Util._canUseSessionStorage;
    };
    /**
     *  Gets the list of session storage keys
     *
     *  @returns {string[]} List of session storage keys
     */
    Util.getSessionStorageKeys = function () {
        var keys = [];
        if (Util.canUseSessionStorage()) {
            for (var key in window.sessionStorage) {
                keys.push(key);
            }
        }
        return keys;
    };
    /**
     *  Get an object from the browser's session storage
     *
     *  @param {string} name - the name of the object to get from storage
     *  @returns {string} The contents of the storage object with the given name. Null if storage is not supported.
     */
    Util.getSessionStorage = function (logger, name) {
        var storage = Util._getSessionStorageObject();
        if (storage !== null) {
            try {
                return storage.getItem(name);
            }
            catch (e) {
                Util._canUseSessionStorage = false;
                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotReadSessionStorage, "Browser failed read of session storage. " + Util.getExceptionName(e), { exception: Util.dump(e) });
            }
        }
        return null;
    };
    /**
     *  Set the contents of an object in the browser's session storage
     *
     *  @param {string} name - the name of the object to set in storage
     *  @param {string} data - the contents of the object to set in storage
     *  @returns {boolean} True if the storage object could be written.
     */
    Util.setSessionStorage = function (logger, name, data) {
        var storage = Util._getSessionStorageObject();
        if (storage !== null) {
            try {
                storage.setItem(name, data);
                return true;
            }
            catch (e) {
                Util._canUseSessionStorage = false;
                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserCannotWriteSessionStorage, "Browser failed write to session storage. " + Util.getExceptionName(e), { exception: Util.dump(e) });
            }
        }
        return false;
    };
    /**
     *  Remove an object from the browser's session storage
     *
     *  @param {string} name - the name of the object to remove from storage
     *  @returns {boolean} True if the storage object could be removed.
     */
    Util.removeSessionStorage = function (logger, name) {
        var storage = Util._getSessionStorageObject();
        if (storage !== null) {
            try {
                storage.removeItem(name);
                return true;
            }
            catch (e) {
                Util._canUseSessionStorage = false;
                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.BrowserFailedRemovalFromSessionStorage, "Browser failed removal of session storage item. " + Util.getExceptionName(e), { exception: Util.dump(e) });
            }
        }
        return false;
    };
    /*
     * Force the SDK not to store and read any data from cookies
     */
    Util.disableCookies = function () {
        CoreUtils.disableCookies();
    };
    /*
     * helper method to tell if document.cookie object is available
     */
    Util.canUseCookies = function (logger) {
        if (CoreUtils._canUseCookies === undefined) {
            CoreUtils._canUseCookies = false;
            try {
                CoreUtils._canUseCookies = Util.document.cookie !== undefined;
            }
            catch (e) {
                logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.CannotAccessCookie, "Cannot access document.cookie - " + Util.getExceptionName(e), { exception: Util.dump(e) });
            }
            ;
        }
        return CoreUtils._canUseCookies;
    };
    /**
     * helper method to set userId and sessionId cookie
     */
    Util.setCookie = function (logger, name, value, domain) {
        var domainAttrib = "";
        var secureAttrib = "";
        if (domain) {
            domainAttrib = ";domain=" + domain;
        }
        if (Util.document.location && Util.document.location.protocol === "https:") {
            secureAttrib = ";secure";
        }
        if (Util.canUseCookies(logger)) {
            Util.document.cookie = name + "=" + value + domainAttrib + ";path=/" + secureAttrib;
        }
    };
    Util.stringToBoolOrDefault = function (str, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        if (str === undefined || str === null) {
            return defaultValue;
        }
        return str.toString().toLowerCase() === "true";
    };
    /**
     * helper method to access userId and sessionId cookie
     */
    Util.getCookie = function (logger, name) {
        if (!Util.canUseCookies(logger)) {
            return;
        }
        var value = "";
        if (name && name.length) {
            var cookieName = name + "=";
            var cookies = Util.document.cookie.split(";");
            for (var i = 0; i < cookies.length; i++) {
                var cookie = cookies[i];
                cookie = Util.trim(cookie);
                if (cookie && cookie.indexOf(cookieName) === 0) {
                    value = cookie.substring(cookieName.length, cookies[i].length);
                    break;
                }
            }
        }
        return value;
    };
    /**
     * Deletes a cookie by setting it's expiration time in the past.
     * @param name - The name of the cookie to delete.
     */
    Util.deleteCookie = function (logger, name) {
        if (Util.canUseCookies(logger)) {
            // Setting the expiration date in the past immediately removes the cookie
            Util.document.cookie = name + "=;path=/;expires=Thu, 01 Jan 1970 00:00:01 GMT;";
        }
    };
    /**
     * helper method to trim strings (IE8 does not implement String.prototype.trim)
     */
    Util.trim = function (str) {
        if (typeof str !== "string")
            return str;
        return str.replace(/^\s+|\s+$/g, "");
    };
    /**
     * generate random id string
     */
    Util.newId = function () {
        var base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        var result = "";
        // tslint:disable-next-line:insecure-random
        var random = Math.random() * 1073741824; //5 symbols in base64, almost maxint
        while (random > 0) {
            var char = base64chars.charAt(random % 64);
            result += char;
            random = Math.floor(random / 64);
        }
        return result;
    };
    /**
     * Check if an object is of type Array
     */
    Util.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    /**
     * Check if an object is of type Error
     */
    Util.isError = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Error]";
    };
    /**
     * Check if an object is of type Date
     */
    Util.isDate = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Date]";
    };
    /**
     * Convert a date to I.S.O. format in IE8
     */
    Util.toISOStringForIE8 = function (date) {
        if (Util.isDate(date)) {
            if (Date.prototype.toISOString) {
                return date.toISOString();
            }
            else {
                var pad = function (num) {
                    var r = String(num);
                    if (r.length === 1) {
                        r = "0" + r;
                    }
                    return r;
                };
                return date.getUTCFullYear()
                    + "-" + pad(date.getUTCMonth() + 1)
                    + "-" + pad(date.getUTCDate())
                    + "T" + pad(date.getUTCHours())
                    + ":" + pad(date.getUTCMinutes())
                    + ":" + pad(date.getUTCSeconds())
                    + "." + String((date.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5)
                    + "Z";
            }
        }
    };
    /**
     * Gets IE version if we are running on IE, or null otherwise
     */
    Util.getIEVersion = function (userAgentStr) {
        if (userAgentStr === void 0) { userAgentStr = null; }
        var myNav = userAgentStr ? userAgentStr.toLowerCase() : navigator.userAgent.toLowerCase();
        return (myNav.indexOf('msie') != -1) ? parseInt(myNav.split('msie')[1]) : null;
    };
    /**
     * Convert ms to c# time span format
     */
    Util.msToTimeSpan = function (totalms) {
        if (isNaN(totalms) || totalms < 0) {
            totalms = 0;
        }
        totalms = Math.round(totalms);
        var ms = "" + totalms % 1000;
        var sec = "" + Math.floor(totalms / 1000) % 60;
        var min = "" + Math.floor(totalms / (1000 * 60)) % 60;
        var hour = "" + Math.floor(totalms / (1000 * 60 * 60)) % 24;
        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));
        ms = ms.length === 1 ? "00" + ms : ms.length === 2 ? "0" + ms : ms;
        sec = sec.length < 2 ? "0" + sec : sec;
        min = min.length < 2 ? "0" + min : min;
        hour = hour.length < 2 ? "0" + hour : hour;
        return (days > 0 ? days + "." : "") + hour + ":" + min + ":" + sec + "." + ms;
    };
    /**
    * Checks if error has no meaningful data inside. Ususally such errors are received by window.onerror when error
    * happens in a script from other domain (cross origin, CORS).
    */
    Util.isCrossOriginError = function (message, url, lineNumber, columnNumber, error) {
        return (message === "Script error." || message === "Script error") && !error;
    };
    /**
    * Returns string representation of an object suitable for diagnostics logging.
    */
    Util.dump = function (object) {
        var objectTypeDump = Object.prototype.toString.call(object);
        var propertyValueDump = JSON.stringify(object);
        if (objectTypeDump === "[object Error]") {
            propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
        }
        return objectTypeDump + propertyValueDump;
    };
    /**
    * Returns the name of object if it's an Error. Otherwise, returns empty string.
    */
    Util.getExceptionName = function (object) {
        var objectTypeDump = Object.prototype.toString.call(object);
        if (objectTypeDump === "[object Error]") {
            return object.name;
        }
        return "";
    };
    /**
     * Adds an event handler for the specified event
     * @param eventName {string} - The name of the event
     * @param callback {any} - The callback function that needs to be executed for the given event
     * @return {boolean} - true if the handler was successfully added
     */
    Util.addEventHandler = function (eventName, callback) {
        if (typeof window === 'undefined' || !window || typeof eventName !== 'string' || typeof callback !== 'function') {
            return false;
        }
        // Create verb for the event
        var verbEventName = 'on' + eventName;
        // check if addEventListener is available
        if (window.addEventListener) {
            window.addEventListener(eventName, callback, false);
        }
        else if (window["attachEvent"]) {
            window["attachEvent"](verbEventName, callback);
        }
        else {
            return false;
        }
        return true;
    };
    /**
     * Tells if a browser supports a Beacon API
     */
    Util.IsBeaconApiSupported = function () {
        return ('sendBeacon' in navigator && navigator.sendBeacon);
    };
    Util.getExtension = function (extensions, identifier) {
        var extension = null;
        var extIx = 0;
        while (!extension && extIx < extensions.length) {
            if (extensions[extIx] && extensions[extIx].identifier === identifier) {
                extension = extensions[extIx];
            }
            extIx++;
        }
        return extension;
    };
    Util.document = typeof document !== "undefined" ? document : {};
    Util._canUseLocalStorage = undefined;
    Util._canUseSessionStorage = undefined;
    // listing only non-geo specific locations
    Util._internalEndpoints = [
        "https://dc.services.visualstudio.com/v2/track",
        "https://breeze.aimon.applicationinsights.io/v2/track",
        "https://dc-int.services.visualstudio.com/v2/track"
    ];
    Util.NotSpecified = "not_specified";
    return Util;
}());
export { Util };
var UrlHelper = /** @class */ (function () {
    function UrlHelper() {
    }
    UrlHelper.parseUrl = function (url) {
        if (!UrlHelper.htmlAnchorElement) {
            UrlHelper.htmlAnchorElement = !!UrlHelper.document.createElement ? UrlHelper.document.createElement('a') : { host: UrlHelper.parseHost(url) }; // fill host field in the fallback case as that is the only externally required field from this fn
        }
        UrlHelper.htmlAnchorElement.href = url;
        return UrlHelper.htmlAnchorElement;
    };
    UrlHelper.getAbsoluteUrl = function (url) {
        var result;
        var a = UrlHelper.parseUrl(url);
        if (a) {
            result = a.href;
        }
        return result;
    };
    UrlHelper.getPathName = function (url) {
        var result;
        var a = UrlHelper.parseUrl(url);
        if (a) {
            result = a.pathname;
        }
        return result;
    };
    UrlHelper.getCompleteUrl = function (method, absoluteUrl) {
        if (method) {
            return method.toUpperCase() + " " + absoluteUrl;
        }
        else {
            return absoluteUrl;
        }
    };
    // Fallback method to grab host from url if document.createElement method is not available
    UrlHelper.parseHost = function (url) {
        var match = url.match(/:\/\/(www[0-9]?\.)?(.[^/:]+)/i);
        if (match != null && match.length > 2 && typeof match[2] === 'string' && match[2].length > 0) {
            return match[2];
        }
        else {
            return null;
        }
    };
    UrlHelper.document = typeof document !== "undefined" ? document : {};
    return UrlHelper;
}());
export { UrlHelper };
var CorrelationIdHelper = /** @class */ (function () {
    function CorrelationIdHelper() {
    }
    /**
    * Checks if a request url is not on a excluded domain list and if it is safe to add correlation headers
    */
    CorrelationIdHelper.canIncludeCorrelationHeader = function (config, requestUrl, currentHost) {
        if (config && config.disableCorrelationHeaders) {
            return false;
        }
        if (!requestUrl) {
            return false;
        }
        var requestHost = UrlHelper.parseUrl(requestUrl).host.toLowerCase();
        if ((!config || !config.enableCorsCorrelation) && requestHost !== currentHost) {
            return false;
        }
        var includedDomains = config && config.correlationHeaderDomains;
        if (includedDomains) {
            var matchExists_1;
            includedDomains.forEach(function (domain) {
                var regex = new RegExp(domain.toLowerCase().replace(/\./g, "\.").replace(/\*/g, ".*"));
                matchExists_1 = matchExists_1 || regex.test(requestHost);
            });
            if (!matchExists_1) {
                return false;
            }
        }
        var excludedDomains = config && config.correlationHeaderExcludedDomains;
        if (!excludedDomains || excludedDomains.length == 0) {
            return true;
        }
        for (var i = 0; i < excludedDomains.length; i++) {
            var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\./g, "\.").replace(/\*/g, ".*"));
            if (regex.test(requestHost)) {
                return false;
            }
        }
        return true;
    };
    /**
    * Combines target appId and target role name from response header.
    */
    CorrelationIdHelper.getCorrelationContext = function (responseHeader) {
        if (responseHeader) {
            var correlationId = CorrelationIdHelper.getCorrelationContextValue(responseHeader, RequestHeaders.requestContextTargetKey);
            if (correlationId && correlationId !== CorrelationIdHelper.correlationIdPrefix) {
                return correlationId;
            }
        }
    };
    /**
    * Gets key from correlation response header
    */
    CorrelationIdHelper.getCorrelationContextValue = function (responseHeader, key) {
        if (responseHeader) {
            var keyValues = responseHeader.split(",");
            for (var i = 0; i < keyValues.length; ++i) {
                var keyValue = keyValues[i].split("=");
                if (keyValue.length == 2 && keyValue[0] == key) {
                    return keyValue[1];
                }
            }
        }
    };
    CorrelationIdHelper.correlationIdPrefix = "cid-v1:";
    return CorrelationIdHelper;
}());
export { CorrelationIdHelper };
var AjaxHelper = /** @class */ (function () {
    function AjaxHelper() {
    }
    AjaxHelper.ParseDependencyPath = function (logger, absoluteUrl, method, commandName) {
        var target, name = commandName, data = commandName;
        if (absoluteUrl && absoluteUrl.length > 0) {
            var parsedUrl = UrlHelper.parseUrl(absoluteUrl);
            target = parsedUrl.host;
            if (!name) {
                if (parsedUrl.pathname != null) {
                    var pathName = (parsedUrl.pathname.length === 0) ? "/" : parsedUrl.pathname;
                    if (pathName.charAt(0) !== '/') {
                        pathName = "/" + pathName;
                    }
                    data = parsedUrl.pathname;
                    name = DataSanitizer.sanitizeString(logger, method ? method + " " + pathName : pathName);
                }
                else {
                    name = DataSanitizer.sanitizeString(logger, absoluteUrl);
                }
            }
        }
        else {
            target = commandName;
            name = commandName;
        }
        return {
            target: target,
            name: name,
            data: data
        };
    };
    return AjaxHelper;
}());
export { AjaxHelper };
/**
 * A utility class that helps getting time related parameters
 */
var DateTimeUtils = /** @class */ (function () {
    function DateTimeUtils() {
    }
    /**
     * Get the number of milliseconds since 1970/01/01 in local timezone
     */
    DateTimeUtils.Now = (typeof window === 'undefined') ? function () { return new Date().getTime(); } :
        (window.performance && window.performance.now && window.performance.timing) ?
            function () {
                return window.performance.now() + window.performance.timing.navigationStart;
            }
            :
                function () {
                    return new Date().getTime();
                };
    /**
     * Gets duration between two timestamps
     */
    DateTimeUtils.GetDuration = function (start, end) {
        var result = null;
        if (start !== 0 && end !== 0 && !CoreUtils.isNullOrUndefined(start) && !CoreUtils.isNullOrUndefined(end)) {
            result = end - start;
        }
        return result;
    };
    return DateTimeUtils;
}());
export { DateTimeUtils };
//# sourceMappingURL=Util.js.map