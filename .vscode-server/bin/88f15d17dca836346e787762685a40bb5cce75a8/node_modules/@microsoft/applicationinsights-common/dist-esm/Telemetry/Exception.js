// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import { StackFrame } from '../Interfaces/Contracts/Generated/StackFrame';
import { ExceptionData } from '../Interfaces/Contracts/Generated/ExceptionData';
import { ExceptionDetails } from '../Interfaces/Contracts/Generated/ExceptionDetails';
import { DataSanitizer } from './Common/DataSanitizer';
import { FieldType } from '../Enums';
import { Util } from '../Util';
import { CoreUtils } from '@microsoft/applicationinsights-core-js';
var Exception = /** @class */ (function (_super) {
    tslib_1.__extends(Exception, _super);
    /**
    * Constructs a new instance of the ExceptionTelemetry object
    */
    function Exception(logger, exception, properties, measurements, severityLevel, id) {
        var _this = _super.call(this) || this;
        _this.aiDataContract = {
            ver: FieldType.Required,
            exceptions: FieldType.Required,
            severityLevel: FieldType.Default,
            properties: FieldType.Default,
            measurements: FieldType.Default
        };
        if (exception instanceof Error) {
            _this.exceptions = [new _ExceptionDetails(logger, exception)];
            _this.properties = DataSanitizer.sanitizeProperties(logger, properties);
            _this.measurements = DataSanitizer.sanitizeMeasurements(logger, measurements);
            if (severityLevel)
                _this.severityLevel = severityLevel;
            if (id)
                _this.id = id;
        }
        else {
            _this.exceptions = exception.exceptions;
            _this.properties = exception.properties;
            _this.measurements = exception.measurements;
            if (exception.severityLevel)
                _this.severityLevel = exception.severityLevel;
            if (exception.id)
                _this.id = exception.id;
            if (exception.problemGroup)
                _this.problemGroup = exception.problemGroup;
            // bool/int types, use isNullOrUndefined
            if (!CoreUtils.isNullOrUndefined(exception.ver))
                _this.ver = exception.ver;
            if (!CoreUtils.isNullOrUndefined(exception.isManual))
                _this.isManual = exception.isManual;
        }
        return _this;
    }
    Exception.CreateFromInterface = function (logger, exception) {
        var exceptions = exception.exceptions
            && exception.exceptions.map(function (ex) { return _ExceptionDetails.CreateFromInterface(logger, ex); });
        var exceptionData = new Exception(logger, tslib_1.__assign({}, exception, { exceptions: exceptions }));
        return exceptionData;
    };
    Exception.prototype.toInterface = function () {
        var _a = this, exceptions = _a.exceptions, properties = _a.properties, measurements = _a.measurements, severityLevel = _a.severityLevel, ver = _a.ver, problemGroup = _a.problemGroup, id = _a.id, isManual = _a.isManual;
        var exceptionDetailsInterface = exceptions instanceof Array
            && exceptions.map(function (exception) { return exception.toInterface(); })
            || undefined;
        return {
            ver: ver,
            exceptions: exceptionDetailsInterface,
            severityLevel: severityLevel,
            properties: properties,
            measurements: measurements,
            problemGroup: problemGroup,
            id: id,
            isManual: isManual
        };
    };
    /**
    * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.
    */
    Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
        return {
            exceptions: [
                {
                    hasFullStack: true,
                    message: message,
                    stack: details,
                    typeName: typeName
                }
            ]
        };
    };
    Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
    Exception.dataType = "ExceptionData";
    return Exception;
}(ExceptionData));
export { Exception };
var _ExceptionDetails = /** @class */ (function (_super) {
    tslib_1.__extends(_ExceptionDetails, _super);
    function _ExceptionDetails(logger, exception) {
        var _this = _super.call(this) || this;
        _this.aiDataContract = {
            id: FieldType.Default,
            outerId: FieldType.Default,
            typeName: FieldType.Required,
            message: FieldType.Required,
            hasFullStack: FieldType.Default,
            stack: FieldType.Default,
            parsedStack: FieldType.Array
        };
        if (exception instanceof Error) {
            _this.typeName = DataSanitizer.sanitizeString(logger, exception.name) || Util.NotSpecified;
            _this.message = DataSanitizer.sanitizeMessage(logger, exception.message) || Util.NotSpecified;
            var stack = exception.stack;
            _this.parsedStack = _ExceptionDetails.parseStack(stack);
            _this.stack = DataSanitizer.sanitizeException(logger, stack);
            _this.hasFullStack = Util.isArray(_this.parsedStack) && _this.parsedStack.length > 0;
        }
        else {
            _this.typeName = exception.typeName;
            _this.message = exception.message;
            _this.stack = exception.stack;
            _this.parsedStack = exception.parsedStack;
            _this.hasFullStack = exception.hasFullStack;
        }
        return _this;
    }
    _ExceptionDetails.prototype.toInterface = function () {
        var parsedStack = this.parsedStack instanceof Array
            && this.parsedStack.map(function (frame) { return frame.toInterface(); });
        var exceptionDetailsInterface = {
            id: this.id,
            outerId: this.outerId,
            typeName: this.typeName,
            message: this.message,
            hasFullStack: this.hasFullStack,
            stack: this.stack,
            parsedStack: parsedStack || undefined
        };
        return exceptionDetailsInterface;
    };
    _ExceptionDetails.CreateFromInterface = function (logger, exception) {
        var parsedStack = (exception.parsedStack instanceof Array
            && exception.parsedStack.map(function (frame) { return _StackFrame.CreateFromInterface(frame); }))
            || exception.parsedStack;
        var exceptionDetails = new _ExceptionDetails(logger, tslib_1.__assign({}, exception, { parsedStack: parsedStack }));
        return exceptionDetails;
    };
    _ExceptionDetails.parseStack = function (stack) {
        var parsedStack = undefined;
        if (typeof stack === "string") {
            var frames = stack.split('\n');
            parsedStack = [];
            var level = 0;
            var totalSizeInBytes = 0;
            for (var i = 0; i <= frames.length; i++) {
                var frame = frames[i];
                if (_StackFrame.regex.test(frame)) {
                    var parsedFrame = new _StackFrame(frames[i], level++);
                    totalSizeInBytes += parsedFrame.sizeInBytes;
                    parsedStack.push(parsedFrame);
                }
            }
            // DP Constraint - exception parsed stack must be < 32KB
            // remove frames from the middle to meet the threshold
            var exceptionParsedStackThreshold = 32 * 1024;
            if (totalSizeInBytes > exceptionParsedStackThreshold) {
                var left = 0;
                var right = parsedStack.length - 1;
                var size = 0;
                var acceptedLeft = left;
                var acceptedRight = right;
                while (left < right) {
                    // check size
                    var lSize = parsedStack[left].sizeInBytes;
                    var rSize = parsedStack[right].sizeInBytes;
                    size += lSize + rSize;
                    if (size > exceptionParsedStackThreshold) {
                        // remove extra frames from the middle
                        var howMany = acceptedRight - acceptedLeft + 1;
                        parsedStack.splice(acceptedLeft, howMany);
                        break;
                    }
                    // update pointers
                    acceptedLeft = left;
                    acceptedRight = right;
                    left++;
                    right--;
                }
            }
        }
        return parsedStack;
    };
    return _ExceptionDetails;
}(ExceptionDetails));
export { _ExceptionDetails };
var _StackFrame = /** @class */ (function (_super) {
    tslib_1.__extends(_StackFrame, _super);
    function _StackFrame(sourceFrame, level) {
        var _this = _super.call(this) || this;
        _this.sizeInBytes = 0;
        _this.aiDataContract = {
            level: FieldType.Required,
            method: FieldType.Required,
            assembly: FieldType.Default,
            fileName: FieldType.Default,
            line: FieldType.Default,
        };
        if (typeof sourceFrame === "string") {
            var frame = sourceFrame;
            _this.level = level;
            _this.method = "<no_method>";
            _this.assembly = Util.trim(frame);
            _this.fileName = "";
            _this.line = 0;
            var matches = frame.match(_StackFrame.regex);
            if (matches && matches.length >= 5) {
                _this.method = Util.trim(matches[2]) || _this.method;
                _this.fileName = Util.trim(matches[4]);
                _this.line = parseInt(matches[5]) || 0;
            }
        }
        else {
            _this.level = sourceFrame.level;
            _this.method = sourceFrame.method;
            _this.assembly = sourceFrame.assembly;
            _this.fileName = sourceFrame.fileName;
            _this.line = sourceFrame.line;
            _this.sizeInBytes = 0;
        }
        _this.sizeInBytes += _this.method.length;
        _this.sizeInBytes += _this.fileName.length;
        _this.sizeInBytes += _this.assembly.length;
        // todo: these might need to be removed depending on how the back-end settles on their size calculation
        _this.sizeInBytes += _StackFrame.baseSize;
        _this.sizeInBytes += _this.level.toString().length;
        _this.sizeInBytes += _this.line.toString().length;
        return _this;
    }
    _StackFrame.CreateFromInterface = function (frame) {
        return new _StackFrame(frame, null /* level is available in frame interface */);
    };
    _StackFrame.prototype.toInterface = function () {
        return {
            level: this.level,
            method: this.method,
            assembly: this.assembly,
            fileName: this.fileName,
            line: this.line
        };
    };
    // regex to match stack frames from ie/chrome/ff
    // methodName=$2, fileName=$4, lineNo=$5, column=$6
    _StackFrame.regex = /^([\s]+at)?(.*?)(\@|\s\(|\s)([^\(\@\n]+):([0-9]+):([0-9]+)(\)?)$/;
    _StackFrame.baseSize = 58; //'{"method":"","level":,"assembly":"","fileName":"","line":}'.length
    return _StackFrame;
}(StackFrame));
export { _StackFrame };
//# sourceMappingURL=Exception.js.map