import { IDiagnosticLogger, IPlugin } from "@microsoft/applicationinsights-core-js";
import { ICorrelationConfig } from "./Interfaces/ICorrelationConfig";
export declare class Util {
    private static document;
    private static _canUseLocalStorage;
    private static _canUseSessionStorage;
    private static _internalEndpoints;
    static NotSpecified: string;
    static disableStorage(): void;
    /**
     * Gets the localStorage object if available
     * @return {Storage} - Returns the storage object if available else returns null
     */
    private static _getLocalStorageObject();
    /**
     * Tests storage object (localStorage or sessionStorage) to verify that it is usable
     * More details here: https://mathiasbynens.be/notes/localstorage-pattern
     * @param storageType Type of storage
     * @return {Storage} Returns storage object verified that it is usable
     */
    private static _getVerifiedStorageObject(storageType);
    /**
     *  Checks if endpoint URL is application insights internal injestion service URL.
     *
     *  @param endpointUrl Endpoint URL to check.
     *  @returns {boolean} True if if endpoint URL is application insights internal injestion service URL.
     */
    static isInternalApplicationInsightsEndpoint(endpointUrl: string): boolean;
    /**
     *  Check if the browser supports local storage.
     *
     *  @returns {boolean} True if local storage is supported.
     */
    static canUseLocalStorage(): boolean;
    /**
     *  Get an object from the browser's local storage
     *
     *  @param {string} name - the name of the object to get from storage
     *  @returns {string} The contents of the storage object with the given name. Null if storage is not supported.
     */
    static getStorage(logger: IDiagnosticLogger, name: string): string;
    /**
     *  Set the contents of an object in the browser's local storage
     *
     *  @param {string} name - the name of the object to set in storage
     *  @param {string} data - the contents of the object to set in storage
     *  @returns {boolean} True if the storage object could be written.
     */
    static setStorage(logger: IDiagnosticLogger, name: string, data: string): boolean;
    /**
     *  Remove an object from the browser's local storage
     *
     *  @param {string} name - the name of the object to remove from storage
     *  @returns {boolean} True if the storage object could be removed.
     */
    static removeStorage(logger: IDiagnosticLogger, name: string): boolean;
    /**
     * Gets the sessionStorage object if available
     * @return {Storage} - Returns the storage object if available else returns null
     */
    private static _getSessionStorageObject();
    /**
     *  Check if the browser supports session storage.
     *
     *  @returns {boolean} True if session storage is supported.
     */
    static canUseSessionStorage(): boolean;
    /**
     *  Gets the list of session storage keys
     *
     *  @returns {string[]} List of session storage keys
     */
    static getSessionStorageKeys(): string[];
    /**
     *  Get an object from the browser's session storage
     *
     *  @param {string} name - the name of the object to get from storage
     *  @returns {string} The contents of the storage object with the given name. Null if storage is not supported.
     */
    static getSessionStorage(logger: IDiagnosticLogger, name: string): string;
    /**
     *  Set the contents of an object in the browser's session storage
     *
     *  @param {string} name - the name of the object to set in storage
     *  @param {string} data - the contents of the object to set in storage
     *  @returns {boolean} True if the storage object could be written.
     */
    static setSessionStorage(logger: IDiagnosticLogger, name: string, data: string): boolean;
    /**
     *  Remove an object from the browser's session storage
     *
     *  @param {string} name - the name of the object to remove from storage
     *  @returns {boolean} True if the storage object could be removed.
     */
    static removeSessionStorage(logger: IDiagnosticLogger, name: string): boolean;
    static disableCookies(): void;
    static canUseCookies(logger: IDiagnosticLogger): any;
    /**
     * helper method to set userId and sessionId cookie
     */
    static setCookie(logger: IDiagnosticLogger, name: any, value: any, domain?: any): void;
    static stringToBoolOrDefault(str: any, defaultValue?: boolean): boolean;
    /**
     * helper method to access userId and sessionId cookie
     */
    static getCookie(logger: IDiagnosticLogger, name: any): string;
    /**
     * Deletes a cookie by setting it's expiration time in the past.
     * @param name - The name of the cookie to delete.
     */
    static deleteCookie(logger: IDiagnosticLogger, name: string): void;
    /**
     * helper method to trim strings (IE8 does not implement String.prototype.trim)
     */
    static trim(str: any): string;
    /**
     * generate random id string
     */
    static newId(): string;
    /**
     * Check if an object is of type Array
     */
    static isArray(obj: any): boolean;
    /**
     * Check if an object is of type Error
     */
    static isError(obj: any): boolean;
    /**
     * Check if an object is of type Date
     */
    static isDate(obj: any): boolean;
    /**
     * Convert a date to I.S.O. format in IE8
     */
    static toISOStringForIE8(date: Date): string;
    /**
     * Gets IE version if we are running on IE, or null otherwise
     */
    static getIEVersion(userAgentStr?: string): number;
    /**
     * Convert ms to c# time span format
     */
    static msToTimeSpan(totalms: number): string;
    /**
    * Checks if error has no meaningful data inside. Ususally such errors are received by window.onerror when error
    * happens in a script from other domain (cross origin, CORS).
    */
    static isCrossOriginError(message: string, url: string, lineNumber: number, columnNumber: number, error: Error): boolean;
    /**
    * Returns string representation of an object suitable for diagnostics logging.
    */
    static dump(object: any): string;
    /**
    * Returns the name of object if it's an Error. Otherwise, returns empty string.
    */
    static getExceptionName(object: any): string;
    /**
     * Adds an event handler for the specified event
     * @param eventName {string} - The name of the event
     * @param callback {any} - The callback function that needs to be executed for the given event
     * @return {boolean} - true if the handler was successfully added
     */
    static addEventHandler(eventName: string, callback: any): boolean;
    /**
     * Tells if a browser supports a Beacon API
     */
    static IsBeaconApiSupported(): boolean;
    static getExtension(extensions: IPlugin[], identifier: string): any;
}
export declare class UrlHelper {
    private static document;
    private static htmlAnchorElement;
    static parseUrl(url: any): HTMLAnchorElement;
    static getAbsoluteUrl(url: any): string;
    static getPathName(url: any): string;
    static getCompleteUrl(method: string, absoluteUrl: string): string;
    static parseHost(url: string): string;
}
export declare class CorrelationIdHelper {
    static correlationIdPrefix: string;
    /**
    * Checks if a request url is not on a excluded domain list and if it is safe to add correlation headers
    */
    static canIncludeCorrelationHeader(config: ICorrelationConfig, requestUrl: string, currentHost: string): boolean;
    /**
    * Combines target appId and target role name from response header.
    */
    static getCorrelationContext(responseHeader: string): string;
    /**
    * Gets key from correlation response header
    */
    static getCorrelationContextValue(responseHeader: string, key: string): string;
}
export declare class AjaxHelper {
    static ParseDependencyPath(logger: IDiagnosticLogger, absoluteUrl: string, method: string, commandName: string): {
        target: any;
        name: string;
        data: string;
    };
}
/**
 * A utility class that helps getting time related parameters
 */
export declare class DateTimeUtils {
    /**
     * Get the number of milliseconds since 1970/01/01 in local timezone
     */
    static Now: () => number;
    /**
     * Gets duration between two timestamps
     */
    static GetDuration: (start: number, end: number) => number;
}
