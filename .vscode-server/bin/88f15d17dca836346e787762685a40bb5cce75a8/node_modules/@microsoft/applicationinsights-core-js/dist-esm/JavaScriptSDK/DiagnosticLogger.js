// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
"use strict";
import { _InternalMessageId, LoggingSeverity } from "../JavaScriptSDK.Enums/LoggingEnums";
import { CoreUtils } from "./CoreUtils";
var _InternalLogMessage = /** @class */ (function () {
    function _InternalLogMessage(msgId, msg, isUserAct, properties) {
        if (isUserAct === void 0) { isUserAct = false; }
        this.messageId = msgId;
        this.message =
            (isUserAct ? _InternalLogMessage.AiUserActionablePrefix : _InternalLogMessage.AiNonUserActionablePrefix) +
                msgId;
        var diagnosticText = (msg ? " message:" + _InternalLogMessage.sanitizeDiagnosticText(msg) : "") +
            (properties ? " props:" + _InternalLogMessage.sanitizeDiagnosticText(JSON.stringify(properties)) : "");
        this.message += diagnosticText;
    }
    _InternalLogMessage.sanitizeDiagnosticText = function (text) {
        return "\"" + text.replace(/\"/g, "") + "\"";
    };
    _InternalLogMessage.dataType = "MessageData";
    /**
     * For user non actionable traces use AI Internal prefix.
     */
    _InternalLogMessage.AiNonUserActionablePrefix = "AI (Internal): ";
    /**
     * Prefix of the traces in portal.
     */
    _InternalLogMessage.AiUserActionablePrefix = "AI: ";
    return _InternalLogMessage;
}());
export { _InternalLogMessage };
var DiagnosticLogger = /** @class */ (function () {
    function DiagnosticLogger(config) {
        /**
        *  Session storage key for the prefix for the key indicating message type already logged
        */
        this.AIInternalMessagePrefix = "AITR_";
        /**
         * When this is true the SDK will throw exceptions to aid in debugging.
         */
        this.enableDebugExceptions = function () { return false; };
        /**
         * 0: OFF
         * 1: CRITICAL (default)
         * 2: >= WARNING
         */
        this.consoleLoggingLevel = function () { return 1; };
        /**
         * 0: OFF (default)
         * 1: CRITICAL
         * 2: >= WARNING
         */
        this.telemetryLoggingLevel = function () { return 0; };
        /**
         * The maximum number of internal messages allowed to be sent per page view
         */
        this.maxInternalMessageLimit = function () { return 25; };
        /**
         * The internal logging queue
         */
        this.queue = [];
        /**
         * Count of internal messages sent
         */
        this._messageCount = 0;
        /**
         * Holds information about what message types were already logged to console or sent to server.
         */
        this._messageLogged = {};
        if (CoreUtils.isNullOrUndefined(config)) {
            // TODO: Use default config
            // config = AppInsightsCore.defaultConfig;
            // For now, use defaults specified in DiagnosticLogger members;
            return;
        }
        if (!CoreUtils.isNullOrUndefined(config.loggingLevelConsole)) {
            this.consoleLoggingLevel = function () { return config.loggingLevelConsole; };
        }
        if (!CoreUtils.isNullOrUndefined(config.loggingLevelTelemetry)) {
            this.telemetryLoggingLevel = function () { return config.loggingLevelTelemetry; };
        }
        if (!CoreUtils.isNullOrUndefined(config.maxMessageLimit)) {
            this.maxInternalMessageLimit = function () { return config.maxMessageLimit; };
        }
        if (!CoreUtils.isNullOrUndefined(config.enableDebugExceptions)) {
            this.enableDebugExceptions = function () { return config.enableDebugExceptions; };
        }
    }
    /**
     * This method will throw exceptions in debug mode or attempt to log the error as a console warning.
     * @param severity {LoggingSeverity} - The severity of the log message
     * @param message {_InternalLogMessage} - The log message.
     */
    DiagnosticLogger.prototype.throwInternal = function (severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) { isUserAct = false; }
        var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
        if (this.enableDebugExceptions()) {
            throw message;
        }
        else {
            if (typeof (message) !== "undefined" && !!message) {
                if (typeof (message.message) !== "undefined") {
                    if (isUserAct) {
                        // check if this message type was already logged to console for this page view and if so, don't log it again
                        var messageKey = +message.messageId;
                        if (!this._messageLogged[messageKey] || this.consoleLoggingLevel() >= LoggingSeverity.WARNING) {
                            this.warnToConsole(message.message);
                            this._messageLogged[messageKey] = true;
                        }
                    }
                    else {
                        // don't log internal AI traces in the console, unless the verbose logging is enabled
                        if (this.consoleLoggingLevel() >= LoggingSeverity.WARNING) {
                            this.warnToConsole(message.message);
                        }
                    }
                    this.logInternalMessage(severity, message);
                }
            }
        }
    };
    /**
     * This will write a warning to the console if possible
     * @param message {string} - The warning message
     */
    DiagnosticLogger.prototype.warnToConsole = function (message) {
        if (typeof console !== "undefined" && !!console) {
            if (typeof console.warn === "function") {
                console.warn(message);
            }
            else if (typeof console.log === "function") {
                console.log(message);
            }
        }
    };
    /**
     * Resets the internal message count
     */
    DiagnosticLogger.prototype.resetInternalMessageCount = function () {
        this._messageCount = 0;
        this._messageLogged = {};
    };
    /**
     * Logs a message to the internal queue.
     * @param severity {LoggingSeverity} - The severity of the log message
     * @param message {_InternalLogMessage} - The message to log.
     */
    DiagnosticLogger.prototype.logInternalMessage = function (severity, message) {
        if (this._areInternalMessagesThrottled()) {
            return;
        }
        // check if this message type was already logged for this session and if so, don't log it again
        var logMessage = true;
        var messageKey = this.AIInternalMessagePrefix + message.messageId;
        // if the session storage is not available, limit to only one message type per page view
        if (this._messageLogged[messageKey]) {
            logMessage = false;
        }
        else {
            this._messageLogged[messageKey] = true;
        }
        if (logMessage) {
            // Push the event in the internal queue
            if (severity <= this.telemetryLoggingLevel()) {
                this.queue.push(message);
                this._messageCount++;
            }
            // When throttle limit reached, send a special event
            if (this._messageCount == this.maxInternalMessageLimit()) {
                var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                var throttleMessage = new _InternalLogMessage(_InternalMessageId.MessageLimitPerPVExceeded, throttleLimitMessage, false);
                this.queue.push(throttleMessage);
                this.warnToConsole(throttleLimitMessage);
            }
        }
    };
    /**
     * Indicates whether the internal events are throttled
     */
    DiagnosticLogger.prototype._areInternalMessagesThrottled = function () {
        return this._messageCount >= this.maxInternalMessageLimit();
    };
    return DiagnosticLogger;
}());
export { DiagnosticLogger };
//# sourceMappingURL=DiagnosticLogger.js.map