// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { DateTimeUtils, Util } from '@microsoft/applicationinsights-common';
import { CoreUtils, LoggingSeverity, _InternalMessageId } from '@microsoft/applicationinsights-core-js';
/**
* Class encapsulates sending page views and page view performance telemetry.
*/
var PageViewManager = /** @class */ (function () {
    function PageViewManager(appInsights, overridePageViewDuration, core, pageViewPerformanceManager) {
        this.pageViewPerformanceSent = false;
        this.overridePageViewDuration = false;
        this.overridePageViewDuration = overridePageViewDuration;
        this.appInsights = appInsights;
        this._pageViewPerformanceManager = pageViewPerformanceManager;
        if (core) {
            this._channel = function () { return (core.getTransmissionControls()); };
            this._logger = core.logger;
        }
    }
    /**
    * Currently supported cases:
    * 1) (default case) track page view called with default parameters, overridePageViewDuration = false. Page view is sent with page view performance when navigation timing data is available.
    *    a. If navigation timing is not supported then page view is sent right away with undefined duration. Page view performance is not sent.
    * 2) overridePageViewDuration = true, custom duration provided. Custom duration is used, page view sends right away.
    * 3) overridePageViewDuration = true, custom duration NOT provided. Page view is sent right away, duration is time spent from page load till now (or undefined if navigation timing is not supported).
    * 4) overridePageViewDuration = false, custom duration is provided. Page view is sent right away with custom duration.
    *
    * In all cases page view performance is sent once (only for the 1st call of trackPageView), or not sent if navigation timing is not supported.
    */
    PageViewManager.prototype.trackPageView = function (pageView, customProperties) {
        var _this = this;
        var name = pageView.name;
        if (CoreUtils.isNullOrUndefined(name) || typeof name !== "string") {
            pageView.name = window.document && window.document.title || "";
        }
        var uri = pageView.uri;
        if (CoreUtils.isNullOrUndefined(uri) || typeof uri !== "string") {
            pageView.uri = window.location && window.location.href || "";
        }
        // case 1a. if performance timing is not supported by the browser, send the page view telemetry with the duration provided by the user. If the user
        // do not provide the duration, set duration to undefined
        // Also this is case 4
        if (!this._pageViewPerformanceManager.isPerformanceTimingSupported()) {
            this.appInsights.sendPageViewInternal(pageView, customProperties);
            this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
            // no navigation timing (IE 8, iOS Safari 8.4, Opera Mini 8 - see http://caniuse.com/#feat=nav-timing)
            this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.NavigationTimingNotSupported, "trackPageView: navigation timing API used for calculation of page duration is not supported in this browser. This page view will be collected without duration and timing info.");
            return;
        }
        var pageViewSent = false;
        var customDuration = undefined;
        // if the performance timing is supported by the browser, calculate the custom duration
        var start = this._pageViewPerformanceManager.getPerformanceTiming().navigationStart;
        customDuration = DateTimeUtils.GetDuration(start, +new Date);
        if (!this._pageViewPerformanceManager.shouldCollectDuration(customDuration)) {
            customDuration = undefined;
        }
        // if the user has provided duration, send a page view telemetry with the provided duration. Otherwise, if
        // overridePageViewDuration is set to true, send a page view telemetry with the custom duration calculated earlier
        var duration = undefined;
        if (!CoreUtils.isNullOrUndefined(customProperties) &&
            !CoreUtils.isNullOrUndefined(customProperties.duration)) {
            duration = customProperties.duration;
        }
        if (this.overridePageViewDuration || !isNaN(duration)) {
            if (isNaN(duration)) {
                // case 3
                if (!customProperties) {
                    customProperties = {};
                }
                customProperties["duration"] = customDuration;
            }
            // case 2
            this.appInsights.sendPageViewInternal(pageView, customProperties);
            this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
            pageViewSent = true;
        }
        // now try to send the page view performance telemetry
        var maxDurationLimit = 60000;
        if (!customProperties) {
            customProperties = {};
        }
        var handle = setInterval((function () {
            try {
                if (_this._pageViewPerformanceManager.isPerformanceTimingDataReady()) {
                    clearInterval(handle);
                    var pageViewPerformance = {
                        name: name,
                        uri: uri
                    };
                    _this._pageViewPerformanceManager.populatePageViewPerformanceEvent(pageViewPerformance);
                    if (!pageViewPerformance.isValid && !pageViewSent) {
                        // If navigation timing gives invalid numbers, then go back to "override page view duration" mode.
                        // That's the best value we can get that makes sense.
                        customProperties["duration"] = customDuration;
                        _this.appInsights.sendPageViewInternal(pageView, customProperties);
                        _this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
                    }
                    else {
                        if (!pageViewSent) {
                            customProperties["duration"] = pageViewPerformance.durationMs;
                            _this.appInsights.sendPageViewInternal(pageView, customProperties);
                        }
                        if (!_this.pageViewPerformanceSent) {
                            _this.appInsights.sendPageViewPerformanceInternal(pageViewPerformance, customProperties);
                            _this.pageViewPerformanceSent = true;
                        }
                        _this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
                    }
                }
                else if (DateTimeUtils.GetDuration(start, +new Date) > maxDurationLimit) {
                    // if performance timings are not ready but we exceeded the maximum duration limit, just log a page view telemetry
                    // with the maximum duration limit. Otherwise, keep waiting until performance timings are ready
                    clearInterval(handle);
                    if (!pageViewSent) {
                        customProperties["duration"] = maxDurationLimit;
                        _this.appInsights.sendPageViewInternal(pageView, customProperties);
                        _this._channel().forEach(function (queues) { queues.forEach(function (q) { return q.flush(true); }); });
                    }
                }
            }
            catch (e) {
                _this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackPVFailedCalc, "trackPageView failed on page load calculation: " + Util.getExceptionName(e), { exception: Util.dump(e) });
            }
        }), 100);
    };
    return PageViewManager;
}());
export { PageViewManager };
//# sourceMappingURL=PageViewManager.js.map